<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.3 (452849)"/><meta name="altitude" content="515"/><meta name="created" content="2015-08-10 15:29:29 +0000"/><meta name="latitude" content="46.62862356756499"/><meta name="longitude" content="13.82448722609675"/><meta name="source" content="mobile.iphone"/><meta name="updated" content="2015-08-10 15:36:19 +0000"/><title>Swap trick for shrink_to_fit</title></head><body>To trim a standard container's excess capacity, you can nowadays use std::container&lt;T&gt;::shrink_to_fit.<div><br/></div><div>Before this method was available, you could use the "swap trick"</div><div><br/></div><div><div>std::container&lt;T&gt; c;</div><div><br/></div><div>c.reserve(1E6); // too much space</div></div><div><br/></div><div><div>std::container&lt;T&gt;(c).swap(c);</div></div><div><br/></div><div>The copy constructed container will only allocate as much space as it needs (= c.size()) or as much as the implementation allows (some implementations have a minimum capacity or needs to a power of two). It will also contain the exact same elements. By swapping the containers, c then has the data without excess capacity and the temporary one does, which will then go out of scope and destruct and free all the capacity.</div></body></html>