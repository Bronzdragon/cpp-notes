<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.3 (452849)"/><meta name="keywords" content="auto, C++, C++11, C++14, templates"/><meta name="created" content="2015-10-17 14:57:26 +0000"/><meta name="updated" content="2015-10-17 16:04:08 +0000"/><title>`auto` Type Deduction</title></head><body>
<!-- Sublime:LS0tCnRpdGxlOiBgYXV0b2AgVHlwZSBEZWR1Y3Rpb24Kbm90ZWJvb2s6IEMrKwp0YWdzOkMrKywgQysrMTEsIEMrKzE0LCBhdXRvLCB0ZW1wbGF0ZXMKLS0tCgpUaGUgdHlwZSBkZWR1Y3Rpb24gcnVsZXMgZm9yIGBhdXRvYCBhcmUgbGFyZ2VseSB0aGUgc2FtZSBhcyBmb3IgdGVtcGxhdGVzLiBJbiBhbiBleHByZXNzaW9uIGxpa2UgdGhpczoKCmBjb25zdCBhdXRvIHggPSA1O2AKCmBhdXRvYCB0YWtlcyB0aGUgcm9sZSBvZiBgVGAgaW4gdGVtcGxhdGUgdHlwZSBkZWR1Y3Rpb24gYW5kIHRoZSAqdHlwZSBzcGVjaWZpZXIqIChgY29uc3QgYXV0b2ApIHRha2VzIHRoZSByb2xlIG9mIHRoZSBwYXJhbWV0ZXIgdHlwZSBgVHlwZWAuCgpUaHVzIGFsbCB0aGVzZSBjYXNlcyB3aWxsIGJlIHRoZSBzYW1lIGFzIGZvciB0ZW1wbGF0ZSB0eXBlIGRlZHVjdGlvbjoKCmBgYEMrKwoKYXV0byB4ID0gNTsgLy8gYXV0byBkZWR1Y2VzIHRvIGludAoKY29uc3QgYXV0byYgcnggPSB4OyAvLyBhdXRvIGRlZHVjZXMgdG8gaW50LCB0aGUgc3BlY2lmaWVyIHRvIGNvbnN0IGludCYKCmF1dG8mJiB1cngxID0geDsgLy8gYXV0byBkZWR1Y2VzIHRvIGludCYsIHRoZSBzcGVjaWZpZXIgdG9vCgphdXRvJiYgdXJ4MiA9IDI3OyAvLyBhdXRvIGRlY3VlcyB0byBpbnQsIHRoZSBzcGVjaWZpZXIgdG8gaW50JiYKCmF1dG8qIHB4ID0gJng7IC8vIGF1dG8gZGVkdWNlcyB0byBpbnQsIHRoZSBzcGVjaWZpZXIgdG8gaW50KgoKaW50IGFyciBbMl0gPSB7MSwgMn07CgphdXRvIGEgPSBhcnI7IC8vIGF1dG8gZGVkdWNlcyB0byBpbnQqIChhcnJheSBkZWNheXMpCgphdXRvJiByYSA9IGFycjsgLy8gYXV0byBkZWR1Y2VzIHRvIGludCAoJikgWzJdCgp2b2lkIGYoaW50LCBzdGQ6OnN0cmluZyk7CgphdXRvIGcgPSBmOyAvLyBhdXRvIGRlZHVjZXMgdG8gdm9pZCAoKikgKGludCwgc3RkOjpzdHJpbmcpCgphdXRvJiBnID0gZjsgLy8gYXV0byBkZWR1Y2VzIHRvIHZvaWQgKCYpIChpbnQsIHN0ZDo6c3RyaW5nKQpgYGAKClRoZXJlIGlzIF9fb25lX18gaW1wb3J0YW50IGRpZmZlcmVuY2UsIHJlZ2FyZGluZyBpbml0aWFsaXplci1saXN0czogdGVtcGxhdGUtdHlwZSBkZWR1Y3Rpb24gZm9yIGEgYnJhY2UtaW5pdGlhbGl6ZWQgc2VxdWVuY2UgZmFpbHMsIHdoaWxlIGBhdXRvYCB3aWxsIGRlZHVjZSBpdCBhcyBhbiBgc3RkOjppbml0aWFsaXplcl9saXN0PFQ+YCBhZnRlciBgVGAgaGFzIGJlZW4gZGVkdWNlZCBmcm9tIHRoZSBlbGVtZW50cyBpbiB0aGUgbGlzdCAoaWYgcG9zc2libGUsIGkuZS4gaWYgYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0IGhhdmUgYSBzaW5nbGUgdHlwZSwgZWxzZSBmYWlscyB0b28pLiBFeGFtcGxlczoKCmBgYEMrKwphdXRvIGEgPSA1OwkJLy8gYXV0byAtPiBpbnQKYXV0byBiKDUpOwkJLy8gYXV0byAtPiBpbnQKYXV0byBjID0gezV9OwkvLyBhdXRvIC0+IHN0ZDo6aW5pdGlhbGl6ZXJfbGlzdDxpbnQ+CmF1dG8gZHs1fTsJCS8vIGF1dG8gLT4gc3RkOjppbml0aWFsaXplcl9saXN0PGludD4gb3IgaW50IC0tIENBUkVGVUwhCmF1dG8gZSA9IHs1LCAxLjB9OwkgLy8gZmFpbHMgKG5vdCBvbmx5IG9uZSB0eXBlKQpgYGAKClNwZWNpYWwgY2FyZSBtdXN0IGJlIHRha2VuIGZvciBgZGAuIEFzIG9mIG5vdywgdGhpcyBkb2VzIGluaXRpYWxpemUgYW4gc3RkOjppbml0aWFsaXplcl9saXN0LiBUbyBlbnN1cmUgdW5pZm9ybSBpbml0aWFsaXphdGlvbiBjYXBhYmlsaXRpZXMsIGhvd2V2ZXIsIHRoaXMgd2lsbCAqdmVyeSBzb29uKiBjaGFuZ2UgdG8gaW5pdGlhbGl6ZSBhbiBpbnRlZ2VyIGFuZCBtYW55IGNvbXBpbGVycyBhbHJlYWR5IGltcGxlbWVudCBpdCB3aGlsZSBvdGhlcnMgd2FybiBhYm91dCBpdC4gU28gaWYgeW91IHdhbnQgdG8gc3RvcmUgYW4gaW5pdGlhbGl6ZXIgbGlzdCBpbiBhbiBgYXV0b2AgdmFyaWFibGUsIHVzZSBgPSB7Li4ufWAgYW5kIG5vdCBgey4uLn1gLgoKV2h5IGRvZXMgYGF1dG9gIGRpZmZlciBmcm9tIHRlbXBsYXRlIHR5cGUgZGVkdWN0aW9uIGZvciBpbml0aWFsaXplciBsaXN0cz8gQmVjYXVzZSB0ZW1wbGF0ZSB0eXBlIGRlZHVjdGlvbiBuZXZlciBpbXBsaWNpdGx5IGNvbnZlcnRzIGFueXRoaW5nLiBDb25zaWRlciB0aGlzIGNhc2U6CgpgYGBDKysKdGVtcGxhdGU8dHlwZW5hbWUgVD4Kdm9pZCBhc3NpZ24oVCYgdGFyZ2V0LCBjb25zdCBUJiBzb3VyY2UpOwoKc3RkOjp2ZWN0b3I8aW50PiB2OwoKYXNzaWduKHYsIHsxLCAyLCAzfSk7CmBgYAoKSW4gdGhpcyBjYXNlLCB3ZXJlIGB7MSwgMiwgM31gIGF1dG9tYXRpY2FsbHkgZGVkdWNlcyB0byBiZSBgc3RkOjppbml0aWFsaXplcl9saXN0PGludD5gLCB0aGlzIG1ldGhvZCBjYWxsIHdvdWxkIGZhaWwgYmVjYXVzZSB0aGUgdHlwZXMgZm9yIGBUYCB3b3VsZCBkaWZmZXIuIFdpdGhvdXQgdGhpcyBhdXRvbWF0aWMgZGVkdWN0aW9uIChjdXJyZW50bHkgaW4gcGxhY2UpLCBgVGAgaXMgZGVkdWNlcyB0byBiZSBgc3RkOjp2ZWN0b3I8aW50PmAgYW5kIGB7MSwgMiwgM31gIGluaXRpYWxpemVzIHRoZSBzb3VyY2UgdmVjdG9yIGNvcnJlY3RseS4KClRoZSBmYWN0IHRoYXQgYGF1dG9gIGF1dG9tYXRpY2FsbHkgZGVkdWNlcyBhIGJyYWNlLWxpc3QgYXMgYW4gYHN0ZDo6aW5pdGlhbGl6ZXJfbGlzdGAgaXMgYSBwb2xhcml6aW5nIHRvcGljIGFuZCB0aGVyZSBleGlzdCBwcm9wb3NhbHMgYWxzbyB0byBiYW4gaXQuCgpBIGxhc3Qgbm90ZSBhYm91dCBgYXV0b2AgaW4gbGFtYmRhcyBvciByZXR1cm4gdHlwZXM6IHRoZXJlLCB0ZW1wbGF0ZSB0eXBlIGRlZHVjdGlvbiBydWxlcyBhcHBseSBhbmQgbm90IGBhdXRvYCB0eXBlIGRlZHVjdGlvbiBydWxlczoKCmBgYEMrKwp0ZW1wbGF0ZTx0eXBlbmFtZSBGdW5jdGlvbj4Kdm9pZCBmKEZ1bmN0aW9uIGZ1bmN0aW9uKQp7CgkvLyBGYWlscywgdGVtcGxhdGUgdHlwZSBkZWR1Y3Rpb24gZG9lcyBub3QgYXV0b21hdGljYWxseQoJLy8gZGVkdWNlIHRoaXMgYXMgc3RkOjppbml0aWFsaXplcl9saXN0CglmdW5jdGlvbih7MSwgMiwgM30pOwkKfQoKYXV0byBnKCkKewoJLy8gQWxzbyBmYWlscyBmb3Igc2FtZSByZWFzb25zIGFzIGFib3ZlLgoJcmV0dXJuIHsxLCAyLCAzfTsKfQoKLy8gSW5pdGlhbGl6ZXMgYSB2YWxpZCBzdGQ6OmluaXRpYWxpemVyX2xpc3QKYXV0byBsaXN0ID0gezEsIDIsIDN9OwpgYGA=-->
<p>The type deduction rules for <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> are largely the same as for templates. In an expression like this:</p>

<p><code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">const auto x = 5;</code></p>

<p><code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> takes the role of <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">T</code> in template type deduction and the <em>type specifier</em> (<code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">const auto</code>) takes the role of the parameter type <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">Type</code>.</p>

<p>Thus all these cases will be the same as for template type deduction:</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#f8f8f8;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #000000; font-weight: bold">auto</span> x <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">5</span>; <span style="color: #999988; font-style: italic">// auto deduces to int</span>

<span style="color: #000000; font-weight: bold">const</span> <span style="color: #000000; font-weight: bold">auto&amp;</span> rx <span style="color: #000000; font-weight: bold">=</span> x; <span style="color: #999988; font-style: italic">// auto deduces to int, the specifier to const int&amp;</span>

<span style="color: #000000; font-weight: bold">auto&amp;&amp;</span> urx1 <span style="color: #000000; font-weight: bold">=</span> x; <span style="color: #999988; font-style: italic">// auto deduces to int&amp;, the specifier too</span>

<span style="color: #000000; font-weight: bold">auto&amp;&amp;</span> urx2 <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">27</span>; <span style="color: #999988; font-style: italic">// auto decues to int, the specifier to int&amp;&amp;</span>

<span style="color: #000000; font-weight: bold">auto*</span> px <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">&amp;</span>x; <span style="color: #999988; font-style: italic">// auto deduces to int, the specifier to int*</span>

<span style="color: #445588; font-weight: bold">int</span> arr [<span style="color: #009999">2</span>] <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #009999">1</span>, <span style="color: #009999">2</span>};

<span style="color: #000000; font-weight: bold">auto</span> a <span style="color: #000000; font-weight: bold">=</span> arr; <span style="color: #999988; font-style: italic">// auto deduces to int* (array decays)</span>

<span style="color: #000000; font-weight: bold">auto&amp;</span> ra <span style="color: #000000; font-weight: bold">=</span> arr; <span style="color: #999988; font-style: italic">// auto deduces to int (&amp;) [2]</span>

<span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">f</span>(<span style="color: #445588; font-weight: bold">int</span>, std<span style="color: #000000; font-weight: bold">::</span>string);

<span style="color: #000000; font-weight: bold">auto</span> g <span style="color: #000000; font-weight: bold">=</span> f; <span style="color: #999988; font-style: italic">// auto deduces to void (*) (int, std::string)</span>

<span style="color: #000000; font-weight: bold">auto&amp;</span> g <span style="color: #000000; font-weight: bold">=</span> f; <span style="color: #999988; font-style: italic">// auto deduces to void (&amp;) (int, std::string)</span>
</code></pre>

<p>There is __one__ important difference, regarding initializer-lists: template-type deduction for a brace-initialized sequence fails, while <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> will deduce it as an <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::initializer_list&lt;T&gt;</code> after <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">T</code> has been deduced from the elements in the list (if possible, i.e. if all elements in the list have a single type, else fails too). Examples:</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#f8f8f8;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #000000; font-weight: bold">auto</span> a <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">5</span>;     <span style="color: #999988; font-style: italic">// auto -&gt; int</span>
<span style="color: #000000; font-weight: bold">auto</span> <span style="color: #990000; font-weight: bold">b</span>(<span style="color: #009999">5</span>);      <span style="color: #999988; font-style: italic">// auto -&gt; int</span>
<span style="color: #000000; font-weight: bold">auto</span> c <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #009999">5</span>};   <span style="color: #999988; font-style: italic">// auto -&gt; std::initializer_list&lt;int&gt;</span>
<span style="color: #000000; font-weight: bold">auto</span> d{<span style="color: #009999">5</span>};      <span style="color: #999988; font-style: italic">// auto -&gt; std::initializer_list&lt;int&gt; or int -- CAREFUL!</span>
<span style="color: #000000; font-weight: bold">auto</span> e <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #009999">5</span>, <span style="color: #009999">1.0</span>};   <span style="color: #999988; font-style: italic">// fails (not only one type)</span>
</code></pre>

<p>Special care must be taken for <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">d</code>. As of now, this does initialize an std::initializer_list. To ensure uniform initialization capabilities, however, this will <em>very soon</em> change to initialize an integer and many compilers already implement it while others warn about it. So if you want to store an initializer list in an <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> variable, use <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">= {...}</code> and not <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">{...}</code>.</p>

<p>Why does <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> differ from template type deduction for initializer lists? Because template type deduction never implicitly converts anything. Consider this case:</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#f8f8f8;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #000000; font-weight: bold">template&lt;typename</span> T<span style="color: #000000; font-weight: bold">&gt;</span>
<span style="color: #445588; font-weight: bold">void</span> assign(T<span style="color: #000000; font-weight: bold">&amp;</span> target, <span style="color: #000000; font-weight: bold">const</span> T<span style="color: #000000; font-weight: bold">&amp;</span> source);

std<span style="color: #000000; font-weight: bold">::</span>vector<span style="color: #000000; font-weight: bold">&lt;</span><span style="color: #445588; font-weight: bold">int</span><span style="color: #000000; font-weight: bold">&gt;</span> v;

assign(v, {<span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>});
</code></pre>

<p>In this case, were <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">{1, 2, 3}</code> automatically deduces to be <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::initializer_list&lt;int&gt;</code>, this method call would fail because the types for <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">T</code> would differ. Without this automatic deduction (currently in place), <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">T</code> is deduces to be <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::vector&lt;int&gt;</code> and <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">{1, 2, 3}</code> initializes the source vector correctly.</p>

<p>The fact that <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> automatically deduces a brace-list as an <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::initializer_list</code> is a polarizing topic and there exist proposals also to ban it.</p>

<p>A last note about <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> in lambdas or return types: there, template type deduction rules apply and not <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> type deduction rules:</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#f8f8f8;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #000000; font-weight: bold">template&lt;typename</span> Function<span style="color: #000000; font-weight: bold">&gt;</span>
<span style="color: #445588; font-weight: bold">void</span> f(Function function)
{
    <span style="color: #999988; font-style: italic">// Fails, template type deduction does not automatically</span>
    <span style="color: #999988; font-style: italic">// deduce this as std::initializer_list</span>
    function({<span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>});    
}

<span style="color: #000000; font-weight: bold">auto</span> g()
{
    <span style="color: #999988; font-style: italic">// Also fails for same reasons as above.</span>
    <span style="color: #000000; font-weight: bold">return</span> {<span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>};
}

<span style="color: #999988; font-style: italic">// Initializes a valid std::initializer_list</span>
<span style="color: #000000; font-weight: bold">auto</span> list <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>};
</code></pre>
</body></html>