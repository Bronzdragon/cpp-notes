<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.3 (452849)"/><meta name="altitude" content="477.29736328125"/><meta name="author" content="petergoldsborough@hotmail.com"/><meta name="created" content="2015-09-22 13:13:42 +0000"/><meta name="latitude" content="48.26255925398949"/><meta name="longitude" content="11.66790667259365"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2015-09-29 19:35:36 +0000"/><title>Prefer member-functions to algorithms with the same name.</title></head><body>
<div>All associative containers provide the following methods, which perform the same function as the equally-named standard algorithms:</div>
<div><br/></div>
<ul>
<li>find</li>
<li>count</li>
<li>lower_bound</li>
<li>upper_bound</li>
<li>equal_range</li>
</ul>
<div><br/></div>
<div>At the same time, lists provide the following methods with the same names as standard algorithms:</div>
<div><br/></div>
<ul>
<li>remove</li>
<li>remove_if</li>
<li>unique</li>
<li>sort</li>
<li>merge</li>
<li>reverse</li>
</ul>
<div><br/></div>
<div>You should always prefer these methods over the appropriate standard algorithms, because (1) they are usually more efficient as they are specialized for this type and do not have to provide general behavior for any range of iterators. Note also that (2) they may have different behavior than standard-algorithms.</div>
<div><br/></div>
<div>Regarding (1):</div>
<div><br/></div>
<div>Imagine that you have a std::set of a million integers and you want to find a specific value x. These are your options:</div>
<div><br/></div>
<div><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">std::set&lt;std::size_t&gt; s;<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">/* Fill ... */</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">auto</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">itr = std::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">find</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(s.begin(), s.end(), x);<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">if</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(itr != s.end())</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">/* ... .*/</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">;<br/>
<br/>
itr = s.find(x);<br/>
<br/></span></div>
<div><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">if</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(itr != s.end())</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">/* ... */</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">;</span></div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div>The first, standard method will look at <b>a million values</b> in the worst case as it does a O(N) linear search across the container. At the same time, std::set::find() will perform <b>around 20</b> lookups in O(lg N) time, as it, knowing that it is an ordered tree structure (red-black) can perform a simple binary search. The standard algorithm must also support unsorted sequences and thus cannot do a binary search.</div>
<div><br/></div>
<div>Note also that for std::map and std::multimap, std::count would use equality and compare pairs, i.e. key and value, std::map::count and std::multimap::count consider only keys and use <b>equivalence</b>, the proper way to assess “sameness” for associative containers:</div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">using</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">map_t =</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #703daa">multimap</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">&lt;</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #02a1f3">string</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #02a1f3">size_t</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">&gt;;<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">map_t</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">m = {{</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #43d34b">"a"</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">1</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">}, {</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #43d34b">"a"</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">}};<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// standard-algorithm, has to look for a pair because dereferncing</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// an associative container's iterators yields std::pairs</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">auto</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">count =</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">count</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(m.</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">begin</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(), m.</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">end</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(),</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">map_t</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #02a1f3">value_type</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #43d34b">"a"</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">1</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">));<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #31595d">println</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(count);<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// However you could do this too nowadays</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/>
count =</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">count_if</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(m.</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">begin</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(), m.</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #3d1d81">end</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">(),<br/>
  [] (</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">const</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #703daa">pair</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">&lt;</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #02a1f3">string</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #00a4e6">std</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">::</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #02a1f3">size_t</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">&gt;&amp; p)<br/>
  {</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #e448ab">return</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">p.first ==</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #43d34b">"a"</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">; });<br/>
<br/>
println(count);<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// But the member algorithm will really only look at keys and also</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// use equivalence, i.e. !(a&lt;b) &amp;&amp; !(b&lt;a), rather than equality, i.e.</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// a == b, which makes more sense for maps if you passed them a different</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// comparision function</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// Again also very much shorter</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/>
count = m.count(</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #43d34b">"a"</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">);<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// Why the above if fucked for std::map, because you can't have more</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// than one key-value pair in a map anyway, since it doesn't</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// allow duplicates. WORKS FOR STD::MULTIMAP, THOUGH!</span><span style="font-style: normal; font-variant: normal; font-weight: normal;"><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/>
<br/></span></span></span></div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;">println(count);</span></span></div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div>Regarding (2):</div>
<div><br/></div>
<div>While std::remove and std::remove_if and std::unique cannot actually modify the range that they are working on because they do not have access to the container and its, for example, erase() method, the variants of those algorithms for std::list can:</div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">std::list&lt;std::size_t&gt; l = {</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">1</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">3</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">4</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">,</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">5</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">};<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// Using std::remove, which can only re-arrange things</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// Also less efficient for list because it has to copy</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// values while the list methods can swap pointers</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures"><br/>
l.erase(std::remove(l.begin(), l.end(),</span> <span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">), l.end());<br/>
<br/></span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #848784">// member algorithm, also much shorter, and more efficient</span></div>
<div><span style="font-family: Menlo;"><span style="font-size: 11px;">l.remove(<span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #f32300">2</span><span style="font: 11.0px Menlo; font-variant-ligatures: no-common-ligatures">);</span></span></span></div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div><span style="font-size: 11px;"><span style="font-family: Menlo;"><br/></span></span></div>
<div> </div>
<div>   </div>
</body></html>