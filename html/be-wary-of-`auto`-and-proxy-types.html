<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.3 (452849)"/><meta name="keywords" content="auto, C++, C++11, C++14"/><meta name="created" content="2015-10-18 15:05:22 +0000"/><meta name="updated" content="2015-10-18 15:28:38 +0000"/><title>Be Wary of `auto` and Proxy Types.</title></head><body>
<!-- Sublime:LS0tCnRpdGxlOiBCZSBXYXJ5IG9mIGBhdXRvYCBhbmQgUHJveHkgVHlwZXMuCm5vdGVib29rOiBDKysKdGFnczpDKyssIEMrKzExLCBDKysxNCwgYXV0bwotLS0KClNvbWUgY2xhc3NlcyBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeSByZXR1cm4gcHJveHkgdHlwZXMsIG1vc3QgcHJvbWluZW50bHkgYHN0ZDo6dmVjdG9yPGJvb2w+YCwgd2hvc2Ugc3Vic3RyaXB0IG9wZXJhdG9yIChgb3BlcmF0b3JbXWApIGRvZXMgbm90IGFjdHVhbGx5IHJldHVybiBhIHJlZmVyZW5jZSB0byBhIHJlYWwgYm9vbCBhbmQgZGVmaW5pdGVseSBub3QgdG8gYSBiaXQsIGJ1dCBhY3R1YWxseSByZXR1cm5zIGEgcHJveHkgb2JqZWN0IG9mIHR5cGUgYHN0ZDo6dmVjdG9yPGJvb2w+OjpyZWZlcmVuY2VgLiBUaGlzIGNhbiBsZWFkIHRvIHByb2JsZW1zIGluIGEgY2FzZSBsaWtlIHRoaXM6CgpgYGBDKysKLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGZsYWcgYml0cyAobm90ZTogbm90IGEgcmVmZXJlbmNlKQpzdGQ6OnZlY3Rvcjxib29sPiBmbGFncygpOwoKYXV0byBmbGFnID0gZmxhZ3MoKVsxXTsKYGBgCgpIZXJlLCBgZmxhZ3NgIHdpbGwgcmV0dXJuIGEgYHN0ZDo6dmVjdG9yPGJvb2w+YCwgd2hpY2ggaXMgdGhlbiBhY2Nlc3NlZCBhdCBpbmRleCBgWzFdYCwgc3VjaCB0aGF0IGEgYHN0ZDo6dmVjdG9yPGJvb2w+OjpyZWZlcmVuY2VgIG9iamVjdCBpcyByZXR1cm5lZC4gVGhlIHByb2JsZW0gaXMgdGhhdCBgYXV0b2Agd2lsbCBzdG9yZSB0aGlzIG9iamVjdCwgbm90IGEgYGJvb2xgLiBCZWNhdXNlIHRoZSByZXR1cm5lZCBvYmplY3QgaXMgbm90IGEgcmVmZXJlbmNlIGJ1dCBzaW1wbHkgYW4gb2JqZWN0IHdpdGggYXV0b21hdGljIHN0b3JhZ2UgZHVyYXRpb24sIGl0IHdpbGwgYmUgY2xlYW5lZC11cCBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzc2lvbi4gVGhlIHJlZmVyZW5jZSBvYmplY3QsIGhvd2V2ZXIsIHdpbGwgc3RpbGwgcG9pbnQgdG8gdGhlIHdvcmQgd2hlcmUgdGhlIHJlbGV2YW50IGJpdCB3YXMgc3RvcmVkIGluIHRoZSBub3ctZGVsZXRlZCBvYmplY3QsIG1lYW5pbmcgeW91IGVuZCB1cCB3aXRoIGEgZGFuZ2xpbmcgcmVmZXJlbmNlL3BvaW50ZXIhCgpUaHVzLCBiZSBzdXJlIHRvIGJlIHdhcnkgYWJvdXQgcHJveHkgdHlwZXMgd2l0aCBhdXRvLCBhbmQgYHN0YXRpY19jYXN0YCB0aGVtIHRvIGdldCB0aGUgdW5kZXJseWluZyB0eXBlIGRpcmVjdGx5IChpLmUuIHRoZSAqZXhwbGljaXRseS10eXBlZC1pbml0aWFsaXplciBpZGlvbSopOgoKYGBgQysrCmF1dG8gZmxhZyA9IHN0YXRpY19jYXN0PGJvb2w+KGZsYWdzKClbMV0pOwpgYGA=-->
<p>Some classes in the standard library return proxy types, most prominently <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::vector&lt;bool&gt;</code>, whose substript operator (<code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">operator[]</code>) does not actually return a reference to a real bool and definitely not to a bit, but actually returns a proxy object of type <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::vector&lt;bool&gt;::reference</code>. This can lead to problems in a case like this:</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#ffffff;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #177500">// Function that returns flag bits (note: not a reference)</span>
<span style="color: #000000">std::vector&lt;</span><span style="color: #AA0D92">bool</span><span style="color: #000000">&gt;</span> <span style="color: #000000">flags</span>();

<span style="color: #AA0D92">auto</span> <span style="color: #000000">flag</span> <span style="color: #000000">=</span> <span style="color: #000000">flags</span>()[<span style="color: #2300CE">1</span>];
</code></pre>

<p>Here, <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">flags</code> will return a <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::vector&lt;bool&gt;</code>, which is then accessed at index <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">[1]</code>, such that a <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">std::vector&lt;bool&gt;::reference</code> object is returned. The problem is that <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">auto</code> will store this object, not a <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">bool</code>. Because the returned object is not a reference but simply an object with automatic storage duration, it will be cleaned-up at the end of the expresssion. The reference object, however, will still point to the word where the relevant bit was stored in the now-deleted object, meaning you end up with a dangling reference/pointer!</p>

<p>Thus, be sure to be wary about proxy types with auto, and <code style="color: #000000; font-family: monospace,monospace; padding: 0.1em 0.2em; margin: 0.1em; font-size: 85%; background-color: #F5F5F5; border-radius: 3px; border: 1px solid #cccccc;">static_cast</code> them to get the underlying type directly (i.e. the <em>explicitly-typed-initializer idiom</em>):</p>

<pre title="C++" style="color: #000000; font-family: monospace,monospace; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #cccccc; border-radius: 3px; overflow: auto; padding: 6px 10px; margin-bottom: 10px;background-color:#ffffff;"><code style="color: black; font-family: monospace,monospace; font-size: 0.9em;"><span style="color: #AA0D92">auto</span> <span style="color: #000000">flag</span> <span style="color: #000000">=</span> <span style="color: #AA0D92">static_cast</span><span style="color: #000000">&lt;</span><span style="color: #AA0D92">bool</span><span style="color: #000000">&gt;</span>(<span style="color: #000000">flags</span>()[<span style="color: #2300CE">1</span>]);
</code></pre>
</body></html>