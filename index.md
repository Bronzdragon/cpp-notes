# index

Braced vs parenthesized initialization
 Prefer lambdas over std::bind
 Use decltype on auto&& parameters to std::forward them
 lambda init capture
 mutable lambda
 Template Type Deduction
 Argument Dependent Lookup
 Special member function generation
 explicit operator bool
 final class
 Definite answer to inline in C++
 std::forward_list
 direct vs copy initialization
 Consider using emplace instead of insert
 inline static members
 super in C++
 std::hash
 Why queue/stack have pop and front
 How you could use a union
 Unicode
 Make sure const functions are thread-safe.
 Threading
 References in containers
 functions as arguments
 throw without argument
 Linked-List Problems
 std::initializer_list by value
 Avoid default lambda captures
 Prefer const_iterators to iterators
 Reference qualifiers
 Declare overriding functions override
 Prefer insert over operator[] for maps
 Use constexpr whenever possible
 Prefer deleted functions to private-undefined ones
 Scoped vs. Unscoped Enums
 Abstract classes without pure virtual methods
 reading a file
 Prevent stack allocation
 Item 45: Use member function templates to accept “all compatible types"
 Plain Old Data (POD)
 Lambdas
 Prefer nullptr to 0 and NULL
 char/short addition
 Prefer `auto` to explicit type declarations.
 The *explicitly-typed-initializer* idiom
 The *explicitly-typed-initializer* idiom
 Prefer alias-declarations over typedefs
 Be Wary of `auto` and Proxy Types.
 The *Explicitly Typed Initializer* Idiom.
 The *explicitly typed initializer* idiom.
 Associative container’s new values
 Swapping without intermediaries
 Viewing types
 `decltype` Deduction Rules
 Untitled
 `auto` Type Deduction
 alignof
 uint<N>_t vs uint<N>_fast_t vs  uint<N>_least_t
 Benchmarking
 Using find, equal_range and other algorithms
 Prefer member-functions to algorithms with the same name.
 std::lower_bound and std::upper_bound
 std::generate
 Gotchas
 internal vs external linkage
 decltype for addition template function
 decltype(x) vs decltype((x))
 Always have comparison functions return false for equal values
 Make functors pure functions
 Design functors for pass-by-value
 Why Functors
 imbue, callback and put_money
 std::accumulate
 std::copy_if to stdout
 caes-insensitive string comparison
 Algorithms that expect sorted ranges
 std::not1
 std::remove
 STL Sorting Algorithms
 Operator Precedence
 print
 inserters
 Operator new vs new operator
 Use std::istreambuf_iterator for fast string stream reading
 Use std::prev and std::next
 Inserting and erasing from a reverse iterator
 Pass the template parameter directly instead of casting
 Const_iterator to iterator
 Avoid in-place modification in set and multiset
 Comparison types for associative containers of pointers
 constexpr
 Values
 Equality vs. Equivalence
 Swap trick for shrink_to_fit
 std::vector<bool>
 Different string implementations
 Template template parameters
 class vs typename
 Re-allocation for string and vector
 Size of array with constexpr
 auto return value
 Allocators
 explicit conversion operator
 max_size
 Default and value initialization
 delete
 Making classes uncopyable
 Inheritance and variables
 final
 Python in C++
 join
 Global variables
 Regex
 Other
 General things
 Inlining
 Item 37: Never redefine a functions’ inherited default parameter value.
 Implementation of move and forward
 Arrow Operator
 Copy and swap
 C++14 user-defined literals
 Size of string literal at compile time with constexpr
 Item 47: Define non-member functions inside templates when type
conversions are desired
 Template specializations
 Call shell process
 std::mem_fn
 Split string
 Arrays
 rvalue references, collapsing rules and perfect forwarding
 noexcept and exception specifications
 weak_ptr
 Item 48: Template Meta Programming (TMP)
 Item 41: Understand implicit interfaces and compile-time polymorphism.
 STL Item 5: Prefer range member functions over single-element methods
 std::istringstream and std::ostringstream
 Integer or float to string
 Item 33: Avoid hiding inherited names.
 The friend keyword
 Design Patterns
 Overriden functions are called even in Base class methods
 Erasing for STL containers
 Fibonacci in C++11
 std::function
 std:: things
 std::bind
 Factorial in C++11
 Item 43: Know how to access names in templatized base classes
 STL methods
 Function pointers
 Slicing raw arrays
 Typedef
 Passing multidimensional arrays to functions
 std::move vs std::forward
 Prefer empty() over size() == 0
 STL Containers
 Logical and Bitwise const
 Compile-time logic and templates
 Item 50: Customizing operator new or operator delete
 dynamic_cast
 Base-class-specific, inherited static member
 Static, const and integral members
 abort() and exit()
 Template specialization
 rvalue and lvalue
 Preprocessing - Compiling - Linking
 Item 42: Understand the two meanings of typename.
 Constructors with curly braces
 Virtual inheritance
 std::bind
 Item 39: Use private inheritance judiciously.
 Item 38: Model “has-a” or “is-implemented-in-terms-of” through
composition.
 Item 36: Never redefine an inherited non-virtual function.
 Item 35: Consider alternatives to virtual functions
 Item 34: Differentiate between inheritance of interface and inheritance
of implementation
 C++11
 Functors
 Item 30: Strive for exception-safe code.
 Casting
 Item 26: Postpone variable definitions as long as possible.
 Item 24: Declare non-member functions when type conversions should
apply to all parameters.
 Item 23: Prefer non-member non-friend functions to member functions.
 Constructing smart pointers
 Item 15: Provide access to raw resources in resource-managing classes
 Const pointers and pointers to const
 Preventing exceptions in destructors
 Reassigning references
 Inheritance and the slicing problem
 Explicit constructors
 Masking integers to chars
 Multiplication and division by 2
 Odd check with bitwise operators
 Implicit conversion operators
 Pointer arithmetic
 Nested template parameters
 Convert reverse_iterator to normal forward iterator
 Clearing an std::stringstream
 Switch cases without break
 Erasing iterator in loop
 Exceptions
 Stream operator overloading
 Iomanip
 Accessing the global scope

